class MinimizeMalwareSpread {
    int[] parent;//making a group under one parent
    int[] size;//size of the groups
    
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;//the length for the graph
        parent = new int[n];
        size = new int[n];
        
        //initialization
        for(int i = 0; i < n;i++){
            parent[i] = i;
            size[i] = 1;
        }
        
        //now do the grouping part
        for(int i = 0;i < n;i++){
            for(int j = 0;j < n;j++){
                if(graph[i][j] == 1){//if it's one then its a vertices 
                    int Pi = find(i);//find parent for i
                    int Pj = find(j);//find parent for j
                    
                    if(Pi != Pj){//if both has not merged yet then merge
                        merge(Pi,Pj);
                    }
                }
            }
        }
        
        //we will make a infected array and check if the infected array contains two initial which belong to the same group then there is no point to remove as the other will infect other definetly
        int infected[] = new int[n];
        for(int in : initial){
            int p1 = find(in);//find parent for it
            infected[p1]++;//for that particular leader make a count if the count is greater than 2 then no point in removing
        }
        
        
        //now making of ans and its size whould be greater means the infected should be 1 and it should be part of bigger group so max number of nodes will be saved 
        int ans = -1;
        int maxSize = -1;
        for(int in : initial){
            int p = find(in);
            if(infected[p] == 1 && size[p] >= maxSize){//as we have to return the min index
                if(maxSize == size[p]){
                    ans = Math.min(ans , in);//select min index
                }else{
                    ans = in;
                    maxSize = size[p];
                }
            }
        }
        
        //if no match found :{
        if(ans == -1){
            Arrays.sort(initial);
            return initial[0];//smallest one
        }
        
        return ans;
    }
    
    private int find(int x){
        if(parent[x] == x)
            return x;
        return parent[x] = find(parent[x]);
    }
    
    private void merge(int u , int v){//union||merge the elements into one group according to greater size
        u = find(u);
        v = find(v);//find parent for both
        
        if(u != v){//if not belong to same parent then merge
            if(size[u] > size[v]){//take part with bigger group
                parent[v] = u;
                size[u]++;
            }else{
                parent[u] = v;
                size[v]++;
            }
        }
    }
    
}